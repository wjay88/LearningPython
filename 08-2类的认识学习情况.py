# 定义类名：大驼峰原则：
# 类中有方法、有属性。
class Cat:

    # 属性：初始化对象。
    def __init__(self, new_name, new_age):
        self.name = new_name
        self.age = new_age

    def __str__(self):
        return "%s的年龄：%d" % (self.name, self.age)
    # 方法
    def eat(self):
        print("猫在吃鱼。。。")

    def drink(self):
        print("猫在喝水。。。。")

    def introduce(self):
        print("%s的年龄是：%d" % (self.name, self.age))
# self变量指向了类别中调用类别方法的对象。谁调用方法，self就指向谁。
# 类别中定义方法至少要保证一个参数：且为第一个：用来传递调用该方法的对象。


# tom = Cat()
tom = Cat("汤姆", 40)
tom.eat()
tom.drink()
# tom.age = "汤姆"
# tom.name = 40
# tom.introduce()

print(tom)  # 没有str的情况下，输出内存位置，有str之后输出str结果。




# 总结：

# init方法创建对象的流程：
#   1、创建一个对象
#   2、python解释器，会自动的调用init方法。
#   3、self会把创建对象的引用传进去。把对象的引用当做参数传递给self进而传递给方法。
#       对象在内存中就是一段空间，self将指向此处。
#       变量其实就是对象在特定命名空间中的名称。
#   4、self指向这个对象，那么默认初始化的值就可以传递到对象
#   5、返回创建对象的引用交给tom变量。

# self将对象传递之后，那么类中的方法都可以作用（修改、调用）对象的属性。实现类中多个方法共享数据。
# 所谓的类，对象属性和方法的模板。对象就是对属性和方法的封装。全局变量的类比学习。
# 不同对象之间的属性（各自数据独立）

# 这个init方法有特殊的功能。因此也称init方法为魔法方法。
# 注意init的返回值：None。

# __str__方法：
# 当取一个对象的描述信息的时候，Python解释器会自动调用__str__这个方法：获取属性信息。
# 此时print(对象)将直接打印出对象在str中的信息。

# 规律总结：
# 方法和方法之间数据属性共享：方法可以对属性设置。（对象里面的方法可以通过属性完成共享数据。）
# 类似函数和函数之间数据传递：通过全局变量来共享传递。（第二种方式：是相互调用。）
# 全局变量的定位就是：在多个函数间共享。

# 函数的由来：把一些具有独立的功能封装起来。
# 对象：把函数的功能（*方法）和全局变量（*属性）封装起来。


# 总结

# __init__定义类的属性，通过模板类定义对象后自动调用属性。非触发。
# __str__描述类别信息。打印要输出的内容，也是自动调用。非触发。

